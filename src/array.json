{
  "const array":                                 { "prefix": "ar",         "body": [ "const ${1:arr} = [];" ],                                                                   "description": "Create an Array\n" },
  "Array.length":                                { "prefix": "arl",        "body": [ "${1:items}.length;" ],                                                                     "description": "Array.length\n" },
  "Array.isArray()":                             { "prefix": "isa",        "body": [ "Array.isArray(${1:value})" ],                                                              "description": "Array.isArray(value);\nreturn 'true' if the value is an Array; otherwise, 'false'.\n" },
  "Array.from(arrayLike)":                       { "prefix": "arfr",       "body": [ "Array.from(${1:arrayLike});" ],                                                            "description": "Array.from(arrayLike);\nreturn a new Array instance, shallow-copied Array instance from an array-like or iterable object.\n" },
  "Array.from(arrayLike, mapFn)":                { "prefix": "arfr",       "body": [ "Array.from(${1:arrayLike}, (${2:item}) => {\n\t${3}\n});" ],                               "description": "Array.from(arrayLike[, mapFn[, thisArg]]);\n" },
  "Array.of(elementN)":                          { "prefix": "arof",       "body": [ "Array.of(${1:elementN});" ],                                                               "description": "Array.of(elementN);\nreturn a new Array instance.\n" },
  "array.concat":                                { "prefix": "arc",        "body": [ "${1:items}.concat(${2:valueN});" ],                                                        "description": "let newArray = oldArray.concat([value1[, value2[, ...[, valueN]]]]);\nreturn a new array\n" },
  "array.copyWithin":                            { "prefix": "arcw",       "body": [ "${1:items}.copyWithin(${2:target}, ${3:start}, ${4:end});" ],                              "description": "array.copyWithin(target[, start[, end]]);\nreturn the modified array\n" },
  "array.entries":                               { "prefix": "are",        "body": [ "${1:items}.entries();" ],                                                                  "description": "array.entries();\nreturn a new Array Iterator object that contains the key/value pairs for each index in the array.\n" },
  "array.every":                                 { "prefix": "arev",       "body": [ "${1:items}.every((${2:item}) => {\n\t${3}\n});" ],                                         "description": "array.every(callback(element[, index[, array]])[, thisArg]);\nreturn 'true' if the callback function returns a truthy value for every array element. Otherwise, 'false'.\nreturns 'true' for any condition put on an empty array\n" },
  "array.fill":                                  { "prefix": "arfill",     "body": [ "${1:items}.fill(${2:value}, ${3:start}, ${4:end});" ],                                     "description": "array.fill(value[, start[, end]]);\nreturn the modified array\n" },
  "array.filter":                                { "prefix": "arf",        "body": [ "${1:items}.filter((${2:item}) => {\n\t${3}\n});" ],                                        "description": "let newArray = array.filter(callback(element[, index[, array]])[, thisArg]);\nreturn a new array\n" },
  "array.find":                                  { "prefix": "arfi",       "body": [ "${1:items}.find((${2:item}) => {\n\t${3}\n});" ],                                          "description": "array.find(callback[, thisArg]);\nreturn the value of the first element in the array that satisfies the provided testing function. Otherwise 'undefined' is returned.\n" },
  "array.findIndex":                             { "prefix": "arfin",      "body": [ "${1:items}.findIndex((${2:item}) => {\n\t${3}\n})" ],                                      "description": "array.findIndex(callback(element[, index[, array]])[, thisArg]);\nreturn the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns '-1'.\n6th edition\n" },
  "array.flat(depth)":                           { "prefix": "arflat",     "body": [ "${1:items}.flat();" ],                                                                     "description": "let newArray = array.flat([depth]);\nreturn a new array\n" },
  "array.flatMap(callback)":                     { "prefix": "arflatMap",  "body": [ "${1:items}.flatMap((${2:value}) => ${3:value});" ],                                        "description": "let newArray = array.flatMap(function callback(currentValue[, index[, array]]) { }[, thisArg]);\nreturn a new array with each element being the result of the callback function and flattened to a depth of '1'.\n" },
  "array.forEach((currentValue) => {})":         { "prefix": "fe",         "body": [ "${1:items}.forEach((${2:item}) => {\n\t${3}\n});" ],                                       "description": "array.forEach(arrow function(currentValue));\n" },
  "array.forEach((currentValue, index) => {})":  { "prefix": "fei",        "body": [ "${1:items}.forEach((${2:item}, ${3:index}) => {\n\t${4}\n});" ],                           "description": "array.forEach(arrow function(currentValue, index));\n" },
  "array.forEach(function(currentValue)":        { "prefix": "fea",        "body": [ "${1:items}.forEach(function(${2:item}) {\n\t${3}\n});" ],                                  "description": "array.forEach(function(currentValue);\n" },
  "array.forEach(function(currentValue, index)": { "prefix": "feai",       "body": [ "${1:items}.forEach(function(${2:item}, ${3:index}) {\n\t${4}\n});" ],                      "description": "array.forEach(function callback(currentValue [, index [, array]]) { }[, thisArg]);\n" },
  "array.includes":                              { "prefix": "ari",        "body": [ "${1:items}.includes(${2:value})" ],                                                        "description": "array.includes(valueToFind[, fromIndex]);\nreturn a Boolean value\n" },
  "array.indexOf":                               { "prefix": "ario",       "body": [ "${1:items}.indexOf(${2:item})" ],                                                          "description": "array.indexOf(searchElement[, fromIndex]);\nreturn the first index of the element in the array; '-1' if not found.\n" },
  "array.join":                                  { "prefix": "arj",        "body": [ "${1:items}.join(${2:separator});" ],                                                       "description": "array.join([separator]);\nreturn a string with all array elements joined. If array.length is 0, the empty string is returned.\n" },
  "array.keys":                                  { "prefix": "ark",        "body": [ "${1:items}.keys();" ],                                                                     "description": "array.keys();\nreturns a new Array Iterator object that contains the keys for each index in the array.\n" },
  "array.lastIndexOf":                           { "prefix": "arlio",      "body": [ "${1:items}.lastIndexOf(${2:item})" ],                                                      "description": "array.lastIndexOf(searchElement[, fromIndex]);\nreturn the last index of the element in the array; '-1' if not found.\n" },
  "array.map":                                   { "prefix": "map",        "body": [ "${1:items}.map((${2:currentValue}) => {\n\t${3}\n});" ],                                   "description": "let newArray = array.map(function callback(currentValue[, index[, array]]) { }[, thisArg]);\nreturn a new array with each element being the result of the callback function.\n" },
  "array.pop":                                   { "prefix": "arp",        "body": [ "${1:items}.pop();" ],                                                                      "description": "array.pop();\nreturn the removed element from the array; 'undefined' if the array is empty.\n" },
  "array.push":                                  { "prefix": "arj",        "body": [ "${1:items}.push(${2:item});" ],                                                            "description": "arr.push(element1[, ...[, elementN]]);\nreturn the new length of the array.\n" },
  "array.reduce":                                { "prefix": "arr",        "body": [ "${1:items}.reduce((${2:accumulator}, ${3:currentValue}) => {\n\treturn ${3}\n});" ],       "description": "array.reduce(callback(accumulator, currentValue[, index[, array]]), [, initialValue]);\nreturn The single value that results from the reduction.\n" },
  "array.reduce​Right":                           { "prefix": "arrr",       "body": [ "${1:items}.reduce​Right((${2:accumulator}, ${3:currentValue}) => {\n\treturn ${4}\n});" ],  "description": "array.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue]);\nreturn the value that results from the reduction.\n" },
  "array.reverse":                               { "prefix": "arre",       "body": [ "${1:items}.reverse();" ],                                                                  "description": "array.reverse();\nreturn the reversed array.\n" },
  "array.shift":                                 { "prefix": "ars",        "body": [ "${1:items}.shift();" ],                                                                    "description": "array.shift();\nreturn the removed element from the array; 'undefined' if the array is empty.\n" },
  "array.slice":                                 { "prefix": "arsl",       "body": [ "${1:items}.slice(${2:begin}, ${3:end});" ],                                                "description": "array.slice([begin[, end]]);\n return a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.\n" },
  "array.some":                                  { "prefix": "arso",       "body": [ "${1:items}.some((${2:item}) => {\n\t${3}\n});" ],                                          "description": "array.some(callback(element[, index[, array]])[, thisArg]);\nreturn 'true' if the callback function returns a truthy value for at least one element in the array. Otherwise, 'false'.\nreturns false for any condition put on an empty array.\n" },
  "array.sort":                                  { "prefix": "arsor",      "body": [ "${1:items}.sort((${2:firstEl}, ${3:secondEl}) => {\n\t${4}\n});" ],                        "description": "array.sort([compareFunction(firstEl, secondEl)]);\nreturn the sorted array. Note that the array is sorted in-place, and no copy is made.\n" },
  "array.splice":                                { "prefix": "arsp",       "body": [ "${1:items}.splice(${2:start}, ${3:deleteCount}, ${4:item});" ],                            "description": "let arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, ...]]]]);\nchanges the contents of an array by removing or replacing existing elements and/or adding new elements in-place.\nreturn an array containing the deleted elements,\nIf no elements are removed, an empty array is returned.\n" },
  "array.unshift":                               { "prefix": "aru",        "body": [ "${1:items}.unshift(${2:item});" ],                                                         "description": "array.unshift(element1[, ...[, elementN]])();\nreturn the new length of the array.\n" },
  "array.values":                                { "prefix": "arv",        "body": [ "${1:items}.values();" ],                                                                   "description": "array.values();\nreturn a new Array Iterator object that contains the values for each index in the array.\n" },
  "array[Symbol.iterator]()":                    { "prefix": "arsi",       "body": [ "${1:items}[Symbol.iterator]();" ],                                                         "description": "array[Symbol.iterator]();\nThe initial value of the @@iterator property is the same function object as the initial value of the values() property.\n" },
  "sequence of 0..n":                            { "prefix": "seq",        "body": [ "[...Array(${1:length}).keys()]${2}" ],                                                     "description": "sequence of 0..n\n" }
}