{
  "String.fromCharCode()":       { "prefix": "sfcc",  "body": ["String.fromCharCode(${1:numN})"],                         "description": "String.fromCharCode(num1[, ...[, numN]])\nreturn a string created from the specified sequence of UTF-16 code units.\n" },
  "String.fromCodePoint()":      { "prefix": "sfcp",  "body": ["String.fromCodePoint(${1:numN})"],                        "description": "String.fromCodePoint(num1[, ...[, numN]])\nreturn a string created by using the specified sequence of code points.\na RangeError is thrown if an invalid Unicode code point is given (e.g. 'RangeError: NaN is not a valid code point').\n" },
  "String.raw()":                { "prefix": "sr",    "body": ["String.raw`${1:templateString}`"],                        "description": "String.raw(callSite, ...substitutions)|String.raw`templateString`\nreturn the raw string form of a given template string.\n" },
  "str.charAt()":                { "prefix": "sca",   "body": ["${1:str}.charAt(${2:index})"],                            "description": "str.charAt(index)\n returns a new string consisting of the single UTF-16 code unit located at the specified offset into the string.\n" },
  "str.charCodeAt()":            { "prefix": "scca",  "body": ["${1:str}.charCodeAt(${2:index})"],                        "description": "str.charCodeAt(index)\nreturn an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n" },
  "str.codePointAt()":           { "prefix": "scpa",  "body": ["${1:str}.codePointAt(${2:position})"],                    "description": "str.codePointAt(pos)\nreturn a non-negative integer that is the Unicode code point value.\n" },
  "str.concat()":                { "prefix": "sc",    "body": ["${1:str}.concat(${2:stringN})"],                          "description": "str.concat(string2[, string3, ..., stringN])\nreturn a new string containing the combined text of the strings provided.\n" },
  "str.endsWith()":              { "prefix": "sew",   "body": ["${1:str}.endsWith(${2:searchString})"],                   "description": "str.endsWith(searchString[, length])\nreturn 'true' if the given characters are found at the end of the string; otherwise, 'false'.\n" },
  "str.includes()":              { "prefix": "sin",   "body": ["${1:str}.includes(${2:searchString})"],                   "description": "str.includes(searchString[, position])\nreturn 'true' if the search string is found anywhere within the given string; otherwise, 'false' if not.\n" },
  "str.indexOf()":               { "prefix": "sio",   "body": ["${1:str}.indexOf(${2:searchValue})"],                     "description": "str.indexOf(searchValue[, fromIndex])\nreturn the index of the first occurrence of searchValue, or '-1' if not found.\nAn empty string searchValue will match at any index between '0' and str.length\n" },
  "str.lastIndexOf()":           { "prefix": "slio",  "body": ["${1:str}.lastIndexOf(${2:searchValue})"],                 "description": "str.lastIndexOf(searchValue[, fromIndex])\nreturn the index of the last occurrence of the specified value; '-1' if not found.\n" },
  "str.localeCompare()":         { "prefix": "slc",   "body": ["${1:str}.localeCompare(${2:compareString})"],             "description": "referenceStr.localeCompare(compareString[, locales[, options]])\nreturn a **negative** number if the reference string occurs before the compare string; **positive** if the reference string occurs after the compare string; **0** if they are equivalent.\n" },
  "str.match()":                 { "prefix": "sm",    "body": ["${1:str}.match(${2:regexp})"],                            "description": "str.match(regexp)\nreturn an **Array** whose contents depend on the presence or absence of the global (**g**) flag, or **null** if no matches are found.\n" },
  "str.matchAll()":              { "prefix": "sma",   "body": ["${1:str}.matchAll(${2:regexp})"],                         "description": "str.matchAll(regexp)\nreturn an iterator of all results matching a string against a regular expression, including capturing groups.\n" },
  "str.normalize()":             { "prefix": "sn",    "body": ["${1:str}.normalize('${2:NFC}')"],                         "description": "str.normalize([form])\n**form**\n- NFC — Normalization Form Canonical Composition.\n- NFD — Normalization Form Canonical Decomposition.\n- NFKC — Normalization Form Compatibility Composition.\n- NFKD — Normalization Form Compatibility Decomposition.\nreturn the Unicode Normalization Form of a given string (if the value isn't a string, it will be converted to one first).\n thrown a **RangeError** is thrown if **form** isn't one of the values specified above.\n" },
  "str.padEnd()":                { "prefix": "spe",   "body": ["${1:str}.padEnd(${2:targetLength}, ${3:padString})"],     "description": "str.padEnd(targetLength [, padString])\nreturn a **String** of the specified length with the pad string applied at the end of the current string.\n" },
  "str.padStart()":              { "prefix": "sps",   "body": ["${1:str}.padStart(${2:targetLength}, ${3:padString})"],   "description": "str.padStart(targetLength [, padString])\nreturn a **String** of the specified length with the pad string applied from the start.\n" },
  "str.repeat()":                { "prefix": "sr",    "body": ["${1:str}.repeat(${2:count})"],                            "description": "str.repeat(count)\nreturn a new string containing the specified number of copies of the given string.\n" },
  "str.replace()":               { "prefix": "sre",   "body": ["${1:str}.replace(${2:regexp}, ${3:newSubStr})"],          "description": "str.replace(regexp|substr, newSubStr|function)\nreturn a new string with some or all matches of a **pattern** replaced by a **replacement**. The **pattern** can be a string or a **RegExp**, and the **replacement** can be a string or a function to be called for each match. If **pattern** is a string, only the first occurrence will be replaced.\nThe original string is left unchanged.\n" },
  "str.search()":                { "prefix": "ss",    "body": ["${1:str}.search(${2:regexp})"],                           "description": "str.search(regexp)\nreturn the index of the first match between the regular expression and the given string; if not found, **-1**.\n" },
  "str.slice()":                 { "prefix": "ssl",   "body": ["${1:str}.slice(${2:beginIndex}, ${3:endIndex})"],         "description": "str.slice(beginIndex[, endIndex])\nreturn a new string containing the extracted section of the string.\n" },
  "str.split()":                 { "prefix": "ssp",   "body": ["${1:str}.split(${2:separator})"],                         "description": "str.split([separator[, limit]])\nreturn an Array of strings split at each point where the separator occurs in the given string.\n" },
  "str.startsWith()":            { "prefix": "ssw",   "body": ["${1:str}.startsWith(${2:searchString}, ${3:position})"],  "description": "str.startsWith(searchString[, position])\nreturn **true** if the given characters are found at the beginning of the string; otherwise, **false**.\n" },
  "str.substring()":             { "prefix": "sss",   "body": ["${1:str}.substring(${2:indexStart}, ${3:indexEnd})"],     "description": "str.substring(indexStart[, indexEnd])\nreturn the part of the string between the start and end indexes, or to the end of the string.\n" },
  "str.toLocaleLowerCase()":     { "prefix": "stllc", "body": ["${1:str}.toLocaleLowerCase()"],                           "description": "str.toLocaleLowerCase([locale, locale, ...])\nreturn a new string representing the calling string converted to lower case, according to any locale-specific case mappings.\n" },
  "str.toLocaleUpperCase()":     { "prefix": "stluc", "body": ["${1:str}.toLocaleUpperCase()"],                           "description": "str.toLocaleUpperCase([locale, locale, ...])\nreturn a new string representing the calling string converted to upper case, according to any locale-specific case mappings.\n" },
  "str.toLowerCase()":           { "prefix": "stlc",  "body": ["${1:str}.toLowerCase()"],                                 "description": "str.toLowerCase()\nreturn a new string representing the calling string converted to lower case.\n" },
  "str.toUpperCase()":           { "prefix": "stuc",  "body": ["${1:str}.toUpperCase()"],                                 "description": "str.toUpperCase()\nreturn a new string representing the calling string converted to upper case.\n" },
  "str.trim()":                  { "prefix": "str",   "body": ["${1:str}.trim()"],                                        "description": "str.trim()\nreturn a new string representing the calling string stripped of whitespace from both ends.\n" },
  "str.trimEnd()":               { "prefix": "ste",   "body": ["${1:str}.trimEnd() //trimRight()"],                         "description": "str.trimEnd()/trimRight()\nreturn a new string representing the calling string stripped of whitespace from its (right) end.\n" },
  "str.trimStart()":             { "prefix": "sts",   "body": ["${1:str}.trimStart() //trimLeft()"],                        "description": "str.trimStart()/trimLeft()\nreturn a new string representing the calling string stripped of whitespace from its beginning (left end).\n" },
  "str[@@iterator]()":           { "prefix": "ssi",   "body": ["${1:str}[Symbol.iterator]"],                              "description": "str[Symbol.iterator]\nreturn a new **Iterator** object.\n" }
}