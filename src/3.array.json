{
  "Array.length":                                { "prefix": "arl",        "body": [ "${1:iterable}.length;" ],                                                                     "description": "Array.length\n" },
  "Array.isArray()":                             { "prefix": "isa",        "body": [ "Array.isArray(${1:value});" ],                                                                "description": "Array.isArray(value)\nreturn 'true' if the value is an Array; otherwise, 'false'.\n" },
  "Array.from(arrayLike)":                       { "prefix": "arfr",       "body": [ "Array.from(${1:arrayLike});" ],                                                               "description": "Array.from(arrayLike)\nreturn a new Array instance, shallow-copied Array instance from an array-like or iterable object.\n" },
  "Array.from(arrayLike, mapFn)":                { "prefix": "arfr",       "body": [ "Array.from(${1:arrayLike}, (${2:item}) => {\n\t${3}\n});" ],                                  "description": "Array.from(arrayLike[, mapFn[, thisArg]])\n" },
  "Array.of(elementN)":                          { "prefix": "arof",       "body": [ "Array.of(${1:elementN});" ],                                                                  "description": "Array.of(elementN)\nreturn a new Array instance.\n" },
  "array.concat":                                { "prefix": "arc",        "body": [ "${1:iterable}.concat(${2:valueN});" ],                                                        "description": "let newArray = oldArray.concat([value1[, value2[, ...[, valueN]]]])\nreturn a new array\n" },
  "array.copyWithin":                            { "prefix": "arcw",       "body": [ "${1:iterable}.copyWithin(${2:target}, ${3:start}, ${4:end});" ],                              "description": "array.copyWithin(target[, start[, end]])\nreturn the modified array\n" },
  "array.entries":                               { "prefix": "are",        "body": [ "${1:iterable}.entries();" ],                                                                  "description": "array.entries()\nreturn a new Array Iterator object that contains the key/value pairs for each index in the array.\n" },
  "array.every":                                 { "prefix": "arev",       "body": [ "${1:iterable}.every((${2:element}) => {\n\t${3}\n});" ],                                      "description": "array.every(callback(element[, index[, array]])[, thisArg])\nreturn 'true' if the callback function returns a truthy value for every array element. Otherwise, 'false'.\nreturns 'true' for any condition put on an empty array\n" },
  "array.fill":                                  { "prefix": "arfill",     "body": [ "${1:iterable}.fill(${2:value}, ${3:start}, ${4:end});" ],                                     "description": "array.fill(value[, start[, end]])\nreturn the modified array\n" },
  "array.filter":                                { "prefix": "arf",        "body": [ "${1:iterable}.filter((${2:element}) => {\n\t${3}\n});" ],                                     "description": "let newArray = array.filter(callback(element[, index[, array]])[, thisArg])\nreturn a new array\n" },
  "array.find":                                  { "prefix": "arfi",       "body": [ "${1:iterable}.find((${2:element}) => {\n\t${3}\n});" ],                                       "description": "array.find(callback[, thisArg])\nreturn the value of the first element in the array that satisfies the provided testing function. Otherwise 'undefined' is returned.\n" },
  "array.findIndex":                             { "prefix": "arfin",      "body": [ "${1:iterable}.findIndex((${2:element}) => {\n\t${3}\n});" ],                                  "description": "array.findIndex(callback(element[, index[, array]])[, thisArg])\nreturn the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns '-1'.\n6th edition\n" },
  "array.flat(depth)":                           { "prefix": "arflat",     "body": [ "${1:iterable}.flat();" ],                                                                     "description": "let newArray = array.flat([depth]);\nreturn a new array\n" },
  "array.flatMap(callback)":                     { "prefix": "arflatMap",  "body": [ "${1:iterable}.flatMap((${2:value}) => ${3:value});" ],                                        "description": "let newArray = array.flatMap(function callback(currentValue[, index[, array]]) { }[, thisArg])\nreturn a new array with each element being the result of the callback function and flattened to a depth of '1'.\n" },
  "array.forEach((currentValue) => {})":         { "prefix": "fea",        "body": [ "${1:iterable}.forEach((${2:currentValue}) => {\n\t${3}\n});" ],                               "description": "array.forEach(arrow function(currentValue))\n" },
  "array.forEach((currentValue, index) => {})":  { "prefix": "feai",       "body": [ "${1:iterable}.forEach((${2:currentValue}, ${3:index}) => {\n\t${4}\n});" ],                   "description": "array.forEach(arrow function(currentValue, index))\n" },
  "array.forEach(function(currentValue)":        { "prefix": "fe",         "body": [ "${1:iterable}.forEach(function(${2:currentValue}) {\n\t${3}\n});" ],                          "description": "array.forEach(function(currentValue)\n" },
  "array.forEach(function(currentValue, index)": { "prefix": "fei",        "body": [ "${1:iterable}.forEach(function(${2:currentValue}, ${3:index}) {\n\t${4}\n});" ],              "description": "array.forEach(function callback(currentValue [, index [, array]]) { }[, thisArg]);\n" },
  "array.includes":                              { "prefix": "ari",        "body": [ "${1:iterable}.includes(${2:valueToFind});" ],                                                 "description": "array.includes(valueToFind[, fromIndex])\nreturn a Boolean value\n" },
  "array.indexOf":                               { "prefix": "ario",       "body": [ "${1:iterable}.indexOf(${2:searchElement});" ],                                                "description": "array.indexOf(searchElement[, fromIndex])\nreturn the first index of the element in the array; '-1' if not found.\n" },
  "array.join":                                  { "prefix": "arj",        "body": [ "${1:iterable}.join(${2:separator});" ],                                                       "description": "array.join([separator])\nreturn a string with all array elements joined. If array.length is 0, the empty string is returned.\n" },
  "array.keys":                                  { "prefix": "ark",        "body": [ "${1:iterable}.keys();" ],                                                                     "description": "array.keys()\nreturns a new Array Iterator object that contains the keys for each index in the array.\n" },
  "array.lastIndexOf":                           { "prefix": "arlio",      "body": [ "${1:iterable}.lastIndexOf(${2:searchElement});" ],                                            "description": "array.lastIndexOf(searchElement[, fromIndex])\nreturn the last index of the element in the array; '-1' if not found.\n" },
  "array.map":                                   { "prefix": "map",        "body": [ "${1:iterable}.map((${2:currentValue}) => {\n\t${3}\n});" ],                                   "description": "let newArray = array.map(function callback(currentValue[, index[, array]]) { }[, thisArg])\nreturn a new array with each element being the result of the callback function.\n" },
  "array.pop":                                   { "prefix": "arp",        "body": [ "${1:iterable}.pop();" ],                                                                      "description": "array.pop()\nreturn the removed element from the array; 'undefined' if the array is empty.\n" },
  "array.push":                                  { "prefix": "arj",        "body": [ "${1:iterable}.push(${2:elementN});" ],                                                        "description": "arr.push(element1[, ...[, elementN]])\nreturn the new length of the array.\n" },
  "array.reduce":                                { "prefix": "arr",        "body": [ "${1:iterable}.reduce((${2:accumulator}, ${3:currentValue}) => {\n\treturn ${3}\n});" ],       "description": "array.reduce(callback(accumulator, currentValue[, index[, array]]), [, initialValue])\nreturn The single value that results from the reduction.\n" },
  "array.reduce​Right":                           { "prefix": "arrr",       "body": [ "${1:iterable}.reduce​Right((${2:accumulator}, ${3:currentValue}) => {\n\treturn ${4}\n});" ],  "description": "array.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])\nreturn the value that results from the reduction.\n" },
  "array.reverse":                               { "prefix": "arre",       "body": [ "${1:iterable}.reverse();" ],                                                                  "description": "array.reverse()\nreturn the reversed array.\n" },
  "array.shift":                                 { "prefix": "ars",        "body": [ "${1:iterable}.shift();" ],                                                                    "description": "array.shift()\nreturn the removed element from the array; 'undefined' if the array is empty.\n" },
  "array.slice":                                 { "prefix": "arsl",       "body": [ "${1:iterable}.slice(${2:begin}, ${3:end});" ],                                                "description": "array.slice([begin[, end]])\n return a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.\n" },
  "array.some":                                  { "prefix": "arso",       "body": [ "${1:iterable}.some((${2:element}) => {\n\t${3}\n});" ],                                       "description": "array.some(callback(element[, index[, array]])[, thisArg])\nreturn 'true' if the callback function returns a truthy value for at least one element in the array. Otherwise, 'false'.\nreturns false for any condition put on an empty array.\n" },
  "array.sort":                                  { "prefix": "arsor",      "body": [ "${1:iterable}.sort((${2:firstEl}, ${3:secondEl}) => {\n\t${4}\n});" ],                        "description": "array.sort([compareFunction(firstEl, secondEl)])\nreturn the sorted array. Note that the array is sorted in-place, and no copy is made.\n" },
  "array.splice":                                { "prefix": "arsp",       "body": [ "${1:iterable}.splice(${2:start}, ${3:deleteCount}, ${4:item});" ],                            "description": "let arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, ...]]]])\nchanges the contents of an array by removing or replacing existing elements and/or adding new elements in-place.\nreturn an array containing the deleted elements,\nIf no elements are removed, an empty array is returned.\n" },
  "array.unshift":                               { "prefix": "aru",        "body": [ "${1:iterable}.unshift(${2:elementN});" ],                                                     "description": "array.unshift(element1[, ...[, elementN]])()\nreturn the new length of the array.\n" },
  "array.values":                                { "prefix": "arv",        "body": [ "${1:iterable}.values();" ],                                                                   "description": "array.values()\nreturn a new Array Iterator object that contains the values for each index in the array.\n" },
  "array[Symbol.iterator]()":                    { "prefix": "arsi",       "body": [ "${1:iterable}[Symbol.iterator]();" ],                                                         "description": "array[Symbol.iterator]()\nThe initial value of the @@iterator property is the same function object as the initial value of the values() property.\n" },
  "sequence of 0..n":                            { "prefix": "seq",        "body": [ "[...Array(${1:length}).keys()]${2}" ],                                                        "description": "sequence of 0..n\n" }
}